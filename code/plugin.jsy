import init_shared from './shared/index.jsy'
import json_protocol from './protocols/json.jsy'
import binary_protocol from './protocols/binary.jsy'
import control_protocol from './protocols/control.jsy'


const default_plugin_options = @:
  plugin_name: 'protocols'
  useStandard: true
  json_pack: JSON.stringify
  custom(protocols) :: return protocols


export default function(plugin_options) ::
  plugin_options = Object.assign @ {}, default_plugin_options, plugin_options
  const { plugin_name, random_id, json_pack } = plugin_options

  return @: subclass, order: -1 // dependent on router plugin's (-2) providing packetParser
  
  function subclass(FabricHub_PI, bases) ::
    const {packetParser} = FabricHub_PI.prototype
    if null==packetParser || ! packetParser.isPacketParser() ::
      throw new TypeError @ `Invalid packetParser for plugin`
    

    const shared = init_shared @ packetParser, @{} random_id, json_pack
    let protocols = @{} shared, random_id, inbound: [], codecs: Object.create(null), 

    if plugin_options.useStandard ::
      protocols = init_protocols @ protocols

    protocols = plugin_options.custom @ protocols
    FabricHub_PI.prototype[plugin_name] = protocols


export function init_protocols(protocols) ::
  const {inbound, codecs, shared} = protocols

  codecs.default = codecs.json = @
    shared.bindTransports @ // 0x0* — JSON body
      inbound, 0x00, json_protocol(shared)

  codecs.binary = @
    shared.bindTransports @ // 0x1* — binary body
      inbound, 0x10, binary_protocol(shared)

  codecs.control = @ // 0xf* — control
    control_protocol @ inbound, 0xf0, shared

  return protocols

