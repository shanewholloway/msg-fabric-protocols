export default function(packetParser, shared) ::
  return @{} createStream


  function createStream(pkt, sink, msgid) ::
    let next=0, fin = false, recvData, rstream
    const state = @{} feed: feed_init, info: pkt.info
    return state

    function feed_init(pkt, as_content) ::
      state.feed = feed_ignore

      const info = pkt.info
      const msg = sink.json_unpack @ pkt.body_utf8()
      rstream = sink.recvStream(msg, info)
      if null == rstream :: return
      check_fns @ rstream, 'on_error', 'on_data', 'on_end' 
      recvData = sink.recvStreamData.bind(sink, rstream, info)

      try ::
        feed_seq(pkt)
      catch err ::
        return rstream.on_error @ err, pkt

      state.feed = feed_body
      if rstream.on_init ::
        return rstream.on_init(msg, pkt)

    function feed_body(pkt, as_content) ::
      recvData()
      let data
      try ::
        feed_seq(pkt)
        data = as_content(pkt, sink)
      catch err ::
        return rstream.on_error @ err, pkt

      if fin ::
        const res = rstream.on_data @ data, pkt
        return rstream.on_end @ res, pkt
      else ::
        return rstream.on_data @ data, pkt

    function feed_ignore(pkt) ::
      try :: feed_seq(pkt)
      catch err ::

    function feed_seq(pkt) ::
      let seq = pkt.info.seq
      if seq >= 0 ::
        if next++ === seq ::
          return // in order
      else ::
        fin = true
        sink.deleteStateFor(msgid)
        if next === -seq ::
          next = 'done'
          return // in-order, last packet

      state.feed = feed_ignore
      next = 'invalid'
      throw new Error @ `Packet out of sequence`


function check_fns(obj, ...keys) ::
  for const key of keys ::
    if 'function' !== typeof obj[key] ::
      throw new TypeError @ `Expected "${key}" to be a function`

