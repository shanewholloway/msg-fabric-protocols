export default control_protocol
export function control_protocol(inbound, high, shared) ::
  const {chooseFraming, random_id} = shared
  const {packPacketObj} = shared.packetParser

  const ping_frame = chooseFraming @: from_id: true, token: true, transport: 'direct'
  const pong_frame = chooseFraming @: from_id: true, msgid: true, transport: 'datagram'

  const pong_type = high|0xe
  inbound[pong_type] = recv_pong
  const ping_type = high|0xf
  inbound[high|0xf] = recv_ping

  return @{} send:ping, ping

  function ping(chan, obj) ::
    if ! obj.token ::
      obj.token = random_id()
    obj.body = JSON.stringify @:
      op: 'ping', ts0: new Date()
    ping_frame.pack(ping_type, obj)
    const pkt = packPacketObj @ obj
    return chan.send @ pkt

  function recv_ping(pkt, sink, router) ::
    ping_frame.unpack(pkt)
    pkt.body = pkt.body_json()
    _send_pong @ pkt.body, pkt, router
    return sink.recvCtrl(pkt.body, pkt.info)

  function _send_pong({ts0}, pkt_ping, router) ::
    const {msgid, id_target, id_router, from_id:r_id} = pkt_ping.info
    const obj = @{} msgid
      from_id: @{} id_target, id_router
      id_router: r_id.id_router, id_target: r_id.id_target
      body: JSON.stringify @:
        op: 'pong', ts0, ts1: new Date()

    pong_frame.pack(pong_type, obj)
    const pkt = packPacketObj @ obj
    return router.dispatch @ [pkt]

  function recv_pong(pkt, sink) ::
    pong_frame.unpack(pkt)
    pkt.body = pkt.body_json()
    return sink.recvCtrl(pkt.body, pkt.info)

