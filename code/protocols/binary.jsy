const noop_encodings = @{}
  encode(obj, buf) :: return buf
  decode(sink, buf) :: return buf

export default binary_protocol
export function binary_protocol(shared, {encode, decode}=noop_encodings) ::
  const {stateFor, createMultipart, createStream} = shared
  const {asBuffer} = shared.packetParser

  return @{}
    packBody

    get datagram() :: return this.direct
    direct: @{}
      t_recv(pkt, sink) ::
        const body_buf = pkt.body_buffer()
        const msg = unpackBodyBuf @ body_buf, sink
        return sink.recvMsg @ msg, pkt.info

    multipart: @{}
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createMultipart
        const body_buf = state.feed(pkt)
        if undefined !== body_buf ::
          const msg = unpackBodyBuf @ body_buf, sink
          return sink.recvMsg @ msg, state.info

    streaming: @{}
      mode: 'bytes'
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createStream
        const body_buf = state.feed(pkt, pkt_buffer)
        if undefined !== body_buf ::
          const msg = unpackBodyBuf @ body_buf, sink
          return sink.recvMsg @ msg, state.info

  function packBody(body, obj) ::
    const body_buf = asBuffer @ body
    return encode(obj, body_buf)
  function unpackBodyBuf(body_buf, sink) ::
    return decode(sink, body_buf)

function pkt_buffer(pkt) :: return pkt.body_buffer()

