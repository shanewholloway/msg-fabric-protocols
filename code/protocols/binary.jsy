const noop_encodings = @{}
  encode(buf, obj, chan) :: return buf
  decode(buf, info, sink) :: return buf

export default binary_protocol
export function binary_protocol(shared, {encode, decode}=noop_encodings) ::
  const {stateFor, createMultipart, createStream} = shared
  const {asBuffer} = shared.packetParser

  return @{}
    packBody

    get datagram() :: return this.direct
    direct: @{}
      t_recv(pkt, sink) ::
        const info = pkt.info
        const body_buf = pkt.body_buffer()
        const msg = unpackBodyBuf @ body_buf, info, sink
        return sink.recvMsg @ msg, info

    multipart: @{}
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createMultipart
        const body_buf = state.feed(pkt)
        if undefined !== body_buf ::
          const info = state.info
          const msg = unpackBodyBuf @ body_buf, info, sink
          return sink.recvMsg @ msg, info

    streaming: @{}
      mode: 'bytes'
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createStream
        const body_buf = state.feed(pkt, pkt_buffer, stream_msg_unpack)
        if undefined !== body_buf ::
          const info = state.info
          const msg = unpackBodyBuf @ body_buf, info, sink
          return sink.recvMsg @ msg, info

      msg_pack(msg, obj, chan) ::
        const msg_buf = pack_utf8 @ json_pack @ msg
        return encode(msg_buf, obj, chan)


  function stream_msg_unpack(pkt, sink) ::
    const json_buf = decode(pkt.body_buffer(), pkt.info, sink)
    return sink.json_unpack @ unpack_utf8(json_buf)

  function packBody(body, obj, chan) ::
    const body_buf = asBuffer @ body
    return encode(body_buf, obj, chan)
  function unpackBodyBuf(body_buf, info, sink) ::
    return decode(body_buf, info, sink)

function pkt_buffer(pkt) :: return pkt.body_buffer()

