const noop_encodings = @{}
  encode(buf, obj, chan) :: return buf
  decode(buf, info, sink) :: return buf

export default json_protocol
export function json_protocol(shared, {encode, decode}=noop_encodings) ::
  const {stateFor, createMultipart, createStream, json_pack} = shared
  const {pack_utf8, unpack_utf8} = shared.packetParser
  const stream_msg_unpack = as_json_content

  return @{}
    packBody

    get datagram() :: return this.direct
    direct: @{}
      t_recv(pkt, sink) ::
        const info = pkt.info
        const msg = unpackBodyBuf @ pkt.body_buffer(), info, sink
        return sink.recvMsg @ msg, info

    multipart: @{}
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createMultipart
        const body_buf = state.feed(pkt)
        if undefined !== body_buf ::
          const info = state.info
          const msg = unpackBodyBuf @ body_buf, info, sink
          return sink.recvMsg @ msg, info

    streaming: @{}
      mode: 'object'
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createStream
        return state.feed(pkt, as_json_content, stream_msg_unpack)

      msg_pack(msg, obj, chan) ::
        const msg_buf = pack_utf8 @ json_pack @ msg
        return encode(msg_buf, obj, chan)


  function packBody(body, obj, chan) ::
    const body_buf = pack_utf8 @ json_pack @ body
    return encode(body_buf, obj, chan)

  function as_json_content(pkt, sink) ::
    const json_buf = decode(pkt.body_buffer(), pkt.info, sink)
    return sink.json_unpack @ unpack_utf8 @ json_buf

  function unpackBodyBuf(body_buf, info, sink) ::
    const json_buf = decode(body_buf, info, sink)
    return sink.json_unpack @ json_buf ? unpack_utf8(json_buf) : undefined

