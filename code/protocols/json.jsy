const noop_encodings = @{}
  encode(buf, obj, chan) :: return buf
  decode(buf, sink) :: return buf

export default json_protocol
export function json_protocol(shared, {encode, decode}=noop_encodings) ::
  const {stateFor, createMultipart, createStream, json_pack} = shared
  const {pack_utf8, unpack_utf8} = shared.packetParser

  return @{}
    packBody

    get datagram() :: return this.direct
    direct: @{}
      t_recv(pkt, sink) ::
        const json_buf = decode @ pkt.body_buffer(), sink
        const msg = unpackBodyBuf @ json_buf, sink
        return sink.recvMsg @ msg, pkt.info

    multipart: @{}
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createMultipart
        const body_buf = state.feed(pkt)
        if undefined !== body_buf ::
          const json_buf = decode @ body_buf, sink
          const msg = unpackBodyBuf @ json_buf, sink
          return sink.recvMsg @ msg, state.info

    streaming: @{}
      mode: 'object'
      t_recv(pkt, sink) ::
        const state = stateFor @ pkt, sink, createStream
        return state.feed(pkt, as_json_content)

  function packBody(body, obj, chan) ::
    const body_buf = pack_utf8 @ json_pack @ body
    return encode(body_buf, obj, chan)

  function as_json_content(pkt, sink) ::
    return unpackBodyBuf @ pkt.body_buffer(), sink, null

  function unpackBodyBuf(body_buf, sink, ifAbsent) ::
    const json_buf = decode(body_buf, sink)
    return sink.json_unpack @ json_buf ? unpack_utf8(json_buf) : ifAbsent

